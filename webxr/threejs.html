<!DOCTYPE html>
<html lang="en">
<head>
<title>three.js vr - cubes</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
</head>
<body>
<script type="module">
import * as THREE from 'https://threejs.org/build/three.module.js'

import { BoxLineGeometry } from 'https://threejs.org/examples/jsm/geometries/BoxLineGeometry.js'
import { VRButton } from 'https://threejs.org/examples/jsm/webxr/VRButton.js'
import { XRControllerModelFactory } from 'https://threejs.org/examples/jsm/webxr/XRControllerModelFactory.js'

var clock = new THREE.Clock()

var container
var camera, scene, raycaster, renderer

var room

var controller, controllerGrip, tempMatrix = new THREE.Matrix4()
var INTERSECTED

var skyFiles1=skyFiles()
var isSkyDome=false

init()
animate()

function skyFiles() {
	const dic={dn:27, rt:28, ft:29, lf:30, bk:31, up:37}
    for(const side in dic) {
        // cors fails from https://s3-eu-west-1.amazonaws.com/apps.playcanvas.com/xp7v1oFB/files/assets/27587{}/1/stormydays_{}_1.png
        dic[side]='sky/stormydays_'+side+'_1.png'
    }
    return [dic.lf, dic.up, dic.ft, dic.rt, dic.dn, dic.bk]
}
function skyDome(scene, url) {
	const loader = new THREE.TextureLoader()
	//-- async

	loader.load(url, (texture) => {
	    const rt = new THREE.WebGLCubeRenderTarget(texture.image.height)
	    rt.fromEquirectangularTexture(renderer, texture)
	    scene.background = rt
	})
	isSkyDome=true
	//-- sync
 	// const texture = loader.load(url)
	// const rt = new THREE.WebGLCubeRenderTarget(texture.image.height)
	// rt.fromEquirectangularTexture(renderer, texture)
	// scene.background = rt
}
function skyBox(scene, files) {
	const ctLoader = new THREE.CubeTextureLoader()
	const skyCubeTexture = ctLoader.load(files)
	scene.background = skyCubeTexture
	isSkyDome=false
}
function randomBox(geometry) {
	var mat = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } )
	var object = new THREE.Mesh( geometry,  mat)

	object.position.x = Math.random() * 4 - 2
	object.position.y = Math.random() * 4
	object.position.z = Math.random() * 4 - 2

	object.rotation.x = Math.random() * 2 * Math.PI
	object.rotation.y = Math.random() * 2 * Math.PI
	object.rotation.z = Math.random() * 2 * Math.PI

	object.scale.x = Math.random() + 0.5
	object.scale.y = Math.random() + 0.5
	object.scale.z = Math.random() + 0.5

	object.userData.velocity = new THREE.Vector3()
	object.userData.velocity.x = Math.random() * 0.01 - 0.005
	object.userData.velocity.y = Math.random() * 0.01 - 0.005
	object.userData.velocity.z = Math.random() * 0.01 - 0.005
	return object	
}
function init() {

	container = document.createElement( 'div' )
	document.body.appendChild( container )

	scene = new THREE.Scene()

	switchBackground()
	//scene.background = new THREE.Color( 0x505050 )

	camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 )
	camera.position.set( 0, 1.6, 3 )
	scene.add( camera )

	//-- lights
	scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) )
	var light = new THREE.DirectionalLight( 0xffffff )
	light.position.set( 1, 1, 1 ).normalize()
	scene.add( light )

	//-- room with grid
	room = new THREE.LineSegments(
		new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),
		new THREE.LineBasicMaterial( { color: 0x808080 } )
	)
	scene.add( room )

	//-- box in room
	var geometry = new THREE.BoxBufferGeometry( 0.5, 0.5, 0.5 )

	// var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0xff00ff } ) )
	// object.position.x = 0
	// object.position.y = 2
	// object.position.z = -2
	// object.userData.velocity = new THREE.Vector3()
	// object.userData.velocity.x = 0.01
	// object.userData.velocity.y = 0
	// object.userData.velocity.z = 0
	// room.add( object )

	for ( var i = 0; i < 200; i ++ ) room.add(randomBox(geometry))

	raycaster = new THREE.Raycaster()

	renderer = new THREE.WebGLRenderer( { antialias: true } )
	renderer.setPixelRatio( window.devicePixelRatio )
	renderer.setSize( window.innerWidth, window.innerHeight )
	renderer.outputEncoding = THREE.sRGBEncoding
	renderer.xr.enabled = true
	container.appendChild( renderer.domElement )

	controller = renderer.xr.getController( 0 )
	controller.addEventListener( 'selectstart',  ()     =>{ controller.userData.isSelecting = true; switchBackground() } )
	controller.addEventListener( 'selectend',    ()     =>{ controller.userData.isSelecting = false } )
	controller.addEventListener( 'connected',    (event)=>{ controller.add(buildController(event.data)) } )
	controller.addEventListener( 'disconnected', ()     =>{ controller.remove(controller.children[0]) } )
	scene.add( controller )

	var controllerModelFactory = new XRControllerModelFactory()
	controllerGrip = renderer.xr.getControllerGrip( 0 )
	controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) )
	scene.add( controllerGrip )

	window.addEventListener( 'resize', onWindowResize, false )

	document.body.appendChild( VRButton.createButton( renderer ) )
}

function switchBackground() {
	if(isSkyDome) {
		skyBox(scene, skyFiles1)
	}
	else {
		skyDome(scene, 'https://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg')
	}
}

function buildController( data ) {
	switch ( data.targetRayMode ) {
		case 'tracked-pointer':
			var geometry = new THREE.BufferGeometry()
			geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) )
			geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) )
			var material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } )
			return new THREE.Line( geometry, material )

		case 'gaze':
			var geometry = new THREE.RingBufferGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 )
			var material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } )
			return new THREE.Mesh( geometry, material )
	}
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight
	camera.updateProjectionMatrix()
	renderer.setSize( window.innerWidth, window.innerHeight )
}

function animate() {
	renderer.setAnimationLoop( render )
}

function render() {
	var delta = clock.getDelta() * 60

	//-- replace first by new box
	if ( controller.userData.isSelecting === true ) {
		var cube = room.children[ 0 ]
		room.remove( cube )

		cube.position.copy( controller.position )
		cube.userData.velocity.x = ( Math.random() - 0.5 ) * 0.02 * delta
		cube.userData.velocity.y = ( Math.random() - 0.5 ) * 0.02 * delta
		cube.userData.velocity.z = ( Math.random() * 0.01 - 0.05 ) * delta
		cube.userData.velocity.applyQuaternion( controller.quaternion )
		room.add( cube )
	}

	//-- find intersections

	tempMatrix.identity().extractRotation( controller.matrixWorld )

	raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld )
	raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix )

	var intersects = raycaster.intersectObjects( room.children )

	if ( intersects.length > 0 ) {
		if ( INTERSECTED != intersects[ 0 ].object ) {
			if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex )
			INTERSECTED = intersects[ 0 ].object
			INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex()
			INTERSECTED.material.emissive.setHex( 0xff0000 )
		}
	} else {
		if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex )
		INTERSECTED = undefined
	}

	// Keep cubes inside room
	for (var cube of room.children) {
		//cube.userData.velocity.multiplyScalar( 1 - ( 0.001 * delta ) )
		cube.position.add( cube.userData.velocity )
		if ( cube.position.x < - 3 || cube.position.x > 3 ) {
			cube.position.x = THREE.MathUtils.clamp( cube.position.x, - 3, 3 )
			cube.userData.velocity.x = - cube.userData.velocity.x
		}
		if ( cube.position.y < 0 || cube.position.y > 6 ) {
			cube.position.y = THREE.MathUtils.clamp( cube.position.y, 0, 6 )
			cube.userData.velocity.y = - cube.userData.velocity.y
		}
		if ( cube.position.z < - 3 || cube.position.z > 3 ) {
			cube.position.z = THREE.MathUtils.clamp( cube.position.z, - 3, 3 )
			cube.userData.velocity.z = - cube.userData.velocity.z
		}
		cube.rotation.x += cube.userData.velocity.x * 2 * delta
		cube.rotation.y += cube.userData.velocity.y * 2 * delta
		cube.rotation.z += cube.userData.velocity.z * 2 * delta
	}

	renderer.render( scene, camera )
}
</script>
</body>
</html>
